package euler

object ProjectEuler {
  /*
   * Even Fibonacci numbers
   *
   * Each new term in the Fibonacci sequence is generated by adding the previous
   * two terms. By starting with 1 and 2, the first 10 terms will be:
   *
   * 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
   *
   * By considering the terms in the Fibonacci sequence whose values do not
   * exceed four million, find the sum of the even-valued terms.
   */
  

//testailussa kestää ärsyttävän kauan


  /* kokeilua 6
    stack overflow ongelma tällä tavalla
    	

        def problem2() :Int = {
            def fib (a :Int, b :Int) :Int =
                    (if (b % 2 == 0) b else 0) + (if (a+b > 4000000) 0 else fib(b, a+b))
            def answer = problem2()
            answer
    }

    en oikeen löytänyt mitään järkevää tapaa implementoida tailia, olettaen että se edes auttaisi
    edellisissä kokeiluissa ongelmia parametrien arvojen kanssa
    ongelmat korjattu muuttamalla koko shaiba ihan erillaiseks
    voisi tehdä hienostelu muutoksia käyttämällä Int:Limit:iä, mutta katsotaan jos sen sitten myöhemmin implementois
    nyt vähän breikkiä... kiitos Joona 
  */
 def problem2(): Int = {
   
    def isEven(x:Int):Boolean = x % 2 == 0
   
    def wantedFib(a:Int, b:Int, sum:Int):Int = {
      if(b > 4000000) {
        sum
      } else if(isEven(b)){
        wantedFib(b, a+b, sum+b)
      } else
        wantedFib(b, a+b, sum)
   }
  wantedFib(0, 1, 0)
  }




  /*
   * Largest palindrome product
   *
   * A palindromic number reads the same both ways. The largest palindrome made
   * from the product of two 2-digit numbers is 9009 = 91 × 99.
   *
   * Find the largest palindrome made from the product of two 3-digit numbers.
   *
   */
   
  /* for toimiikin scalassa?
    tärkeintä tajuta muuttaa numerot Stringeiksi ja vaatia että on sama toisinpäin
    Tutki lisää mitä kaikeka yieldillä voi tehdä.
    
  */
    def problem4(): Int = {
      //((for (x <- 100 until 1000; y <- x until 1000) yield x * y) filter (x => x.toString == x.toString.reverse)).max
      
      //joonan ohjeistuksella ilman for looppia
        def lista(a:Int, b:Int): List[Int] = {
          
          Range(a,b).toList
          
        }
      
      lista(100,999).view.flatMap(a =>lista(100,999).map(b => a*b)).filter(a =>(a.toString == a.toString.reverse)).max
    }


  /*
   * Special Pythagorean triplet
   *
   * A Pythagorean triplet is a set of three natural numbers, a < b < c, for
   * which, a^2 + b^2 = c^2
   *
   * For example, 3^2 + 4^2 = 9 + 16 = 25 = 5^2.
   *
   * There exists exactly one Pythagorean triplet for which a + b + c = 1000.
   * Find the product abc.
   */
   
   /*
      jokainen koklmion sivu pitää rajata oleman alle 1000
      sitten vain annetaan if lauseelle säännöt siihen mitä vaadittavien numeroiden pitää täyttää
      lopuksi yieldataan vaadittu kertoma ja siitä head(vastauksia on vain yksi, mutta tällä tavalla sen saa nätisti ulos)
   */
    def problem9(): Int ={
      (for{
        a <- (1 until 1000)
        b <- (a until 1000)
        c <- (b until 1000)
        if (a*a + b*b == c*c && a+b+c == 1000 && a<b && b<c)
      }yield a*b*c).head
    }
  
  //rules((a*a + b*b == c*c && a < b && b < c && a+b+c == 1000)


  /*
   * Maximum path sum I
   *
   * By starting at the top of the triangle below and moving to adjacent numbers
   * on the row below, the maximum total from top to bottom is 23.
   *
   *      3
   *     7 4
   *    2 4 6
   *   8 5 9 3
   *
   * That is, 3 + 7 + 4 + 9 = 23.
   *
   * Find the maximum total from top to bottom of the given triangle with 15
   * rows:
   */
  def problem18(triangle: List[List[Int]]): Int = ???

  /*
   * Maximum path sum II
   *
   * By starting at the top of the triangle below and moving to adjacent numbers
   * on the row below, the maximum total from top to bottom is 23.
   *
   *    3
   *   7 4
   *  2 4 6
   * 8 5 9 3
   *
   * That is, 3 + 7 + 4 + 9 = 23.
   *
   * Find the maximum total from top to bottom in the given triangle with
   * one-hundred rows.
   *
   * NOTE: This is a much more difficult version of Problem 18. It is not
   * possible to try every route to solve this problem, as there are 2^99
   * altogether! If you could check one trillion (10^12) routes every second it
   * would take over twenty billion years to check them all. There is an
   * efficient algorithm to solve it. ;o)
   */
  def problem67(triangle: List[List[Int]]): Int = ???
}
